<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resultados - Jarvis Analyst</title>
    <meta name="description" content="Resultados y análisis del sistema Jarvis Analyst">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    
    <link rel="stylesheet" href="/static/styles.css?v=1.0">
    
    <!-- Theme -->
    <script>
        (function() {
            const theme = localStorage.getItem('theme') || 
                (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
            document.documentElement.classList.toggle('dark', theme === 'dark');
        })();
    </script>
    
    <style>
        /* Layout Principal */
        .main-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            background: var(--bg-primary, #ffffff);
            min-height: 100vh;
        }
        
        /* Seguimiento de Progreso */
        .progress-tracker {
            background: var(--bg-secondary, #f8fafc);
            border: 1px solid var(--border-color, #e2e8f0);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .progress-title {
            font-weight: 600;
            color: var(--text-primary, #1e293b);
            font-size: 1.1rem;
        }
        
        .progress-close {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 4px;
            color: var(--text-secondary, #64748b);
            transition: all 0.2s ease;
        }
        
        .progress-close:hover {
            background: var(--bg-hover, #f1f5f9);
            color: var(--text-primary, #1e293b);
        }
        
        .progress-bar-container {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 0.75rem;
        }
        
        .progress-bar {
            flex: 1;
            height: 8px;
            background: var(--bg-tertiary, #e2e8f0);
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #1d4ed8);
            border-radius: 4px;
            transition: width 0.3s ease;
            position: relative;
        }
        
        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: shimmer 2s infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .progress-text {
            font-weight: 600;
            color: var(--text-primary, #1e293b);
            min-width: 3rem;
            text-align: right;
        }
        
        .progress-message {
            color: var(--text-secondary, #64748b);
            font-size: 0.9rem;
            font-style: italic;
        }
        
        /* Header Simple */
        .page-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color, #E2E8F0);
        }
        
        .page-title {
            font-size: 2rem;
            font-weight: 600;
            color: var(--brand-blue, #1565C0);
            margin: 0;
        }
        
        .header-actions {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        
        /* Botones Simples */
        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .btn-primary {
            background: var(--brand-blue, #1565C0);
            color: white;
        }
        
        .btn-primary:hover {
            background: #1976D2;
        }
        
        .btn-secondary {
            background: var(--text-muted, #94A3B8);
            color: white;
        }
        
        .btn-secondary:hover {
            background: var(--text-secondary, #64748B);
        }
        
        .btn-outline {
            background: transparent;
            color: var(--brand-blue, #1565C0);
            border: 1px solid var(--brand-blue, #1565C0);
        }
        
        .btn-outline:hover {
            background: var(--brand-blue, #1565C0);
            color: white;
        }
        
        /* Sección de Controles */
        .controls-section {
            background: var(--bg-primary, white);
            border: 1px solid var(--border-color, #E2E8F0);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .controls-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--text-primary, #1E293B);
            margin: 0 0 1rem 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }
        
        /* Búsqueda Simple */
        .search-container {
            margin-bottom: 2rem;
        }
        
        .search-box {
            position: relative;
            max-width: 400px;
        }
        
        .search-input {
            width: 100%;
            padding: 0.75rem 2.5rem 0.75rem 1rem;
            border: 1px solid var(--border-color, #E2E8F0);
            border-radius: 8px;
            background: var(--bg-primary, white);
            color: var(--text-primary, #1E293B);
            font-size: 1rem;
        }
        
        .search-icon {
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-muted, #94A3B8);
            width: 16px;
            height: 16px;
        }
        
        /* Métricas Simples */
        .metrics-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }
        
        .metric-card {
            background: var(--bg-primary, white);
            border: 1px solid var(--border-color, #E2E8F0);
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
        }
        
        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--brand-blue, #1565C0);
            margin-bottom: 0.25rem;
        }
        
        .metric-label {
            font-size: 0.9rem;
            color: var(--text-muted, #94A3B8);
        }
        
        /* Resultados */
        .results-section {
            margin-top: 2rem;
        }
        
        .results-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-primary, #1E293B);
            margin-bottom: 1rem;
        }
        
        .result-card {
            background: var(--bg-primary, white);
            border: 1px solid var(--border-color, #E2E8F0);
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            transition: all 0.2s ease;
        }
        
        .result-card:hover {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transform: translateY(-1px);
        }
        
        .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .result-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary, #1E293B);
            margin: 0;
        }
        
        .result-timestamp {
            color: var(--text-muted, #94A3B8);
            font-size: 0.9rem;
        }
        
        .result-content {
            color: var(--text-secondary, #64748B);
            line-height: 1.6;
        }
        
        /* JSON Formatting */
        /* Estilos JSON removidos - ya no se necesitan */
        
        /* Interactive Controls Styles */
        .interactive-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }
        
        /* Lazy Loading Styles */
        .content-placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 20px;
            background: var(--bg-secondary);
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: var(--text-muted);
        }
        
        .content-placeholder:hover {
            background: var(--bg-primary);
            border-color: var(--brand-blue);
            color: var(--brand-blue);
        }
        
        .loading-content {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 20px;
            color: var(--text-muted);
        }
        
        .test-counter {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--bg-primary);
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }
        
        .counter-label {
            font-size: 0.9rem;
            color: var(--text-muted);
            font-weight: 500;
        }
        
        .counter-value {
            font-size: 1.1rem;
            color: var(--text-primary);
            font-weight: 600;
            background: var(--accent-color);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            min-width: 24px;
            text-align: center;
        }
        
        /* Interactive List Styles */
        .interactive-list {
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            max-height: 400px;
            overflow-y: auto;
        }
        
        .list-item {
            padding: 8px 12px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background-color 0.2s ease;
        }
        
        .list-item:last-child {
            border-bottom: none;
        }
        
        .list-item.expandable {
            cursor: pointer;
        }
        
        .list-item.expandable:hover {
            background: var(--bg-primary);
        }
        
        .item-toggle {
            font-size: 0.8rem;
            color: var(--text-muted);
            width: 12px;
            text-align: center;
            transition: transform 0.2s ease;
        }
        
        .item-key {
            font-weight: 500;
            color: var(--accent-color);
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        }
        
        .item-value {
            color: var(--text-primary);
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            flex: 1;
        }
        
        .item-type {
            font-size: 0.8rem;
            color: var(--text-muted);
            font-style: italic;
        }
        
        .item-children {
            margin-left: 20px;
            border-left: 2px solid var(--border-color);
            padding-left: 10px;
        }
        
        .item-children .list-item {
            padding: 4px 8px;
        }
        
        /* Test Results Styles */
        .test-counter-old {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }
        
        .counter-item {
            background: var(--bg-secondary, #F8FAFC);
            border: 1px solid var(--border-color, #E2E8F0);
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
            min-width: 80px;
            flex: 1;
        }
        
        .counter-item.success {
            background: #f0fdf4;
            border-color: #22c55e;
        }
        
        .counter-item.error {
            background: #fef2f2;
            border-color: #ef4444;
        }
        
        .counter-item.warning {
            background: #fffbeb;
            border-color: #f59e0b;
        }
        
        .counter-value {
            display: block;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-primary, #1E293B);
            margin-bottom: 0.25rem;
        }
        
        .counter-label {
            font-size: 0.875rem;
            color: var(--text-muted, #64748B);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .test-list {
            margin-top: 1.5rem;
        }
        
        .test-list h4 {
            margin: 0 0 1rem 0;
            color: var(--text-primary, #1E293B);
            font-size: 1rem;
            font-weight: 600;
        }
        
        .keyword-list {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 300px;
            overflow-y: auto;
            background: var(--bg-secondary, #F8FAFC);
            border: 1px solid var(--border-color, #E2E8F0);
            border-radius: 6px;
            padding: 0.5rem;
        }
        
        .keyword-list li {
            padding: 0.5rem;
            border-bottom: 1px solid var(--border-color, #E2E8F0);
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 0.875rem;
            color: var(--text-secondary, #64748B);
        }
        
        .keyword-list li:last-child {
            border-bottom: none;
        }
        
        .keyword-list li:hover {
            background: var(--bg-primary, #FFFFFF);
        }
        
        .json-bracket {
            color: #ffd700;
            font-weight: bold;
        }
        
        .json-comma {
            color: #d4d4d4;
        }
        
        .json-colon {
            color: #d4d4d4;
            margin: 0 0.25rem;
        }
        
        /* Métricas Detalladas */
        .detailed-metrics-section {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            border: 1px solid var(--border-color);
        }
        
        .detailed-metrics-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            color: var(--text-primary);
            font-size: 1.25rem;
            font-weight: 600;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
        }
        
        .metric-breakdown {
            background: var(--bg-secondary);
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid var(--border-color);
        }
        
        .metric-breakdown h4 {
            margin: 0 0 1rem 0;
            color: var(--text-primary);
            font-size: 1rem;
            font-weight: 600;
        }
        
        .category-item, .time-item, .score-item, .performance-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .category-item:last-child, .time-item:last-child, 
        .score-item:last-child, .performance-item:last-child {
            border-bottom: none;
        }
        
        .metric-name {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
        
        .metric-value-detail {
            color: var(--text-primary);
            font-weight: 600;
            font-size: 0.9rem;
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: var(--border-color);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 0.25rem;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #22c55e, #16a34a);
            transition: width 0.3s ease;
        }
        
        .toggle-detailed-btn {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            margin-top: 1rem;
            transition: all 0.2s ease;
        }
        
        .toggle-detailed-btn:hover {
            background: var(--accent-hover);
            transform: translateY(-1px);
        }
        
        /* JSON Controls */
        .json-controls {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            flex-wrap: wrap;
        }
        
        .json-btn {
            padding: 0.25rem 0.75rem;
            background: var(--brand-blue, #1565C0);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: background 0.2s;
        }
        
        .json-btn:hover {
            background: #1976D2;
        }
        
        .json-btn.secondary {
            background: var(--text-muted, #94A3B8);
        }
        
        .json-btn.secondary:hover {
            background: var(--text-secondary, #64748B);
        }
        
        /* Estados */
        .loading {
            text-align: center;
            padding: 3rem;
            color: var(--text-muted, #94A3B8);
        }
        
        .error {
            color: #dc2626;
            background: #fef2f2;
            border: 1px solid #fecaca;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
        }
        
        .no-results {
            text-align: center;
            padding: 3rem;
            color: var(--text-muted, #94A3B8);
            font-size: 1.1rem;
        }
        
        /* Evaluation Summary Interface */
        .evaluation-summary {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            margin: 15px 0;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .summary-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }

        .summary-header h4 {
            margin: 0;
            color: var(--text-primary);
            font-size: 18px;
        }

        .models-count {
            background: var(--brand-blue);
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-item {
            background: var(--bg-secondary);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid var(--border-color);
            transition: transform 0.2s;
        }

        .stat-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .stat-value {
            display: block;
            font-size: 24px;
            font-weight: bold;
            color: var(--text-primary);
            margin-bottom: 5px;
        }

        .stat-item.success .stat-value {
            color: #22c55e;
        }

        .stat-item.error .stat-value {
            color: #ef4444;
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .models-summary {
            background: var(--bg-secondary);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            margin-bottom: 20px;
        }

        .model-summary {
            padding: 8px 0;
            border-bottom: 1px solid var(--border-color);
            color: var(--text-primary);
        }

        .model-summary:last-child {
            border-bottom: none;
        }

        .json-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .main-container {
                padding: 1rem;
            }
            
            .page-header {
                flex-direction: column;
                gap: 1rem;
                align-items: flex-start;
            }
            
            .header-actions {
                width: 100%;
                justify-content: flex-start;
            }
            
            .controls-grid {
                grid-template-columns: 1fr;
            }
            
            .metrics-section {
                grid-template-columns: repeat(2, 1fr);
            }
            

        }
        
        @media (max-width: 480px) {
            .metrics-section {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- Header Simple -->
        <div class="page-header">
            <h1 class="page-title">Resultados del Sistema</h1>
            <div class="header-actions">
                <button class="theme-toggle" id="themeToggle" aria-label="Toggle theme">
                    <i data-lucide="sun" class="sun-icon"></i>
                    <i data-lucide="moon" class="moon-icon"></i>
                </button>
                <button class="btn btn-outline" onclick="window.location.href='/static/index.html'">
                    <i data-lucide="arrow-left"></i>
                    Volver al Chat
                </button>
                <button class="btn btn-primary" onclick="exportResults()">
                    <i data-lucide="download"></i>
                    Exportar
                </button>
            </div>
        </div>
        
        <!-- Controles Principales -->
        <div class="controls-section">
            <h2 class="controls-title">
                <i data-lucide="settings"></i>
                Controles
            </h2>
            <div class="controls-grid">
                <button class="btn btn-primary" onclick="loadResults()">
                    <i data-lucide="refresh-cw"></i>
                    Actualizar
                </button>
                <button class="btn btn-primary" onclick="runTests()">
                    <i data-lucide="play"></i>
                    Ejecutar Pruebas
                </button>
                <button class="btn btn-primary" onclick="runEvaluations()">
                    <i data-lucide="check-circle"></i>
                    Evaluaciones
                </button>

            </div>
        </div>
        
        <!-- Búsqueda -->
        <div class="search-container">
            <div class="search-box">
                <input type="text" id="searchInput" class="search-input" placeholder="Buscar en resultados..." onkeyup="filterResults()">
                <i data-lucide="search" class="search-icon"></i>
            </div>
        </div>
        
        <!-- Métricas -->
        <div class="metrics-section">
            <div class="metric-card">
                <div class="metric-value" id="totalTests">0</div>
                <div class="metric-label">Total Prompts</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="successRate">0%</div>
                <div class="metric-label">Tasa de Éxito</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="avgTime">0s</div>
                <div class="metric-label">Tiempo Promedio</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="uptime">0/100</div>
                <div class="metric-label">Puntuación Media</div>
            </div>
            <button class="toggle-detailed-btn" onclick="toggleDetailedMetrics()" id="toggleDetailedBtn" style="display: none;">
                <i data-lucide="chevron-down"></i>
                Ver Análisis Detallado
            </button>
        </div>
        
        <!-- Métricas Detalladas -->
        <div class="detailed-metrics-section" id="detailedMetrics" style="display: none;">
            <h3 class="detailed-metrics-title">
                <i data-lucide="bar-chart-3"></i>
                Análisis Detallado
            </h3>
            <div class="metrics-grid">
                <div class="metric-breakdown">
                    <h4>Desglose por Categorías</h4>
                    <div id="categoryBreakdown"></div>
                </div>
                <div class="metric-breakdown">
                    <h4>Distribución de Tiempos</h4>
                    <div id="timeBreakdown"></div>
                </div>
                <div class="metric-breakdown">
                    <h4>Distribución de Puntuaciones</h4>
                    <div id="scoreDistribution"></div>
                </div>
                <div class="metric-breakdown">
                    <h4>Resumen de Rendimiento</h4>
                    <div id="performanceSummary"></div>
                </div>
            </div>
        </div>
        
        <!-- Resultados -->
        <div class="results-section">
            <h2 class="results-title">Resultados</h2>
            
            <div id="loadingMessage" class="loading" style="display: none;">
                <i data-lucide="loader-2" style="animation: spin 1s linear infinite;"></i>
                Cargando resultados...
            </div>
            
            <div id="errorMessage" class="error" style="display: none;"></div>
            
            <div id="resultsContainer">
                <div class="no-results">
                    <i data-lucide="inbox"></i>
                    <p>No hay resultados disponibles</p>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Variables globales
        let allResults = [];
        let filteredResults = [];
        
        // Variables para paginación optimizada
        let currentMetadataPage = 1;
        let totalMetadataPages = 1;
        let metadataCache = new Map();
        
        // Cargar metadatos de resultados (optimizado)
        async function loadResultsMetadata(page = 1, limit = 20) {
            const loadingEl = document.getElementById('loadingMessage');
            const errorEl = document.getElementById('errorMessage');
            
            loadingEl.style.display = 'block';
            errorEl.style.display = 'none';
            
            try {
                const response = await fetch(`/api/results/metadata?page=${page}&limit=${limit}`);
                if (!response.ok) {
                    throw new Error(`Error ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Actualizar variables de paginación
                currentMetadataPage = data.page;
                totalMetadataPages = data.total_pages;
                
                // Convertir metadatos a formato compatible
                allResults = data.metadata.map(meta => ({
                    id: meta.id,
                    title: meta.filename,
                    timestamp: meta.modified,
                    type: meta.type,
                    status: meta.status,
                    summary: meta.summary,
                    metadata: meta,
                    // Datos se cargarán bajo demanda
                    data: null
                }));
                
                filteredResults = [...allResults];
                
                displayResults();
                updateMetrics();
                
            } catch (error) {
                console.error('Error loading results metadata:', error);
                errorEl.textContent = `Error al cargar resultados: ${error.message}`;
                errorEl.style.display = 'block';
            } finally {
                loadingEl.style.display = 'none';
            }
        }
        
        // Cargar detalle completo de un resultado
        async function loadResultDetail(resultId) {
            // Verificar si ya está en caché
            if (metadataCache.has(resultId)) {
                return metadataCache.get(resultId);
            }
            
            try {
                const response = await fetch(`/api/results/detail/${resultId}`);
                if (!response.ok) {
                    throw new Error(`Error ${response.status}: ${response.statusText}`);
                }
                
                const detail = await response.json();
                
                // Guardar en caché
                metadataCache.set(resultId, detail.data);
                
                return detail.data;
                
            } catch (error) {
                console.error(`Error loading detail for ${resultId}:`, error);
                throw error;
            }
        }
        
        // Cargar resultados (función principal - mantiene compatibilidad)
        async function loadResults() {
            await loadResultsMetadata(currentMetadataPage);
        }
        
        // Variables para paginación virtual
        let currentPage = 1;
        const itemsPerPage = 20;
        
        // Mostrar resultados con paginación virtual
        function displayResults() {
            const container = document.getElementById('resultsContainer');
            
            if (filteredResults.length === 0) {
                container.innerHTML = `
                    <div class="no-results">
                        <i data-lucide="inbox"></i>
                        <p>No hay resultados disponibles</p>
                    </div>
                `;
                lucide.createIcons();
                return;
            }
            
            // Calcular elementos a mostrar
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = Math.min(startIndex + itemsPerPage, filteredResults.length);
            const visibleResults = filteredResults.slice(startIndex, endIndex);
            
            // Crear fragmento de documento para mejor rendimiento
            const fragment = document.createDocumentFragment();
            
            visibleResults.forEach((result, index) => {
                // Asignar ID único si no existe
                if (!result.id) {
                    result.id = `result_${startIndex + index}_${Date.now()}`;
                }
                
                const resultDiv = document.createElement('div');
                resultDiv.className = 'result-card';
                resultDiv.innerHTML = `
                    <div class="result-header">
                        <h3 class="result-title">${result.title || 'Resultado'}</h3>
                        <span class="result-timestamp">${formatTimestamp(result.timestamp)}</span>
                    </div>
                    <div class="result-content">
                        ${formatResultContent(result)}
                    </div>
                `;
                fragment.appendChild(resultDiv);
            });
            
            // Limpiar y agregar contenido
            container.innerHTML = '';
            container.appendChild(fragment);
            
            // Agregar controles de paginación
            addPaginationControls(container);
            
            lucide.createIcons();
        }
        
        // Agregar controles de paginación
        function addPaginationControls(container) {
            const totalPages = Math.ceil(filteredResults.length / itemsPerPage);
            
            if (totalPages <= 1) return;
            
            const paginationDiv = document.createElement('div');
            paginationDiv.className = 'pagination-controls';
            paginationDiv.style.cssText = `
                display: flex;
                justify-content: center;
                align-items: center;
                gap: 10px;
                margin: 20px 0;
                padding: 20px;
            `;
            
            // Botón anterior
            const prevBtn = document.createElement('button');
            prevBtn.className = 'btn btn-outline';
            prevBtn.textContent = '← Anterior';
            prevBtn.disabled = currentPage === 1;
            prevBtn.onclick = () => {
                if (currentPage > 1) {
                    currentPage--;
                    displayResults();
                }
            };
            
            // Información de página
            const pageInfo = document.createElement('span');
            pageInfo.textContent = `Página ${currentPage} de ${totalPages} (${filteredResults.length} resultados)`;
            pageInfo.style.cssText = 'color: var(--text-muted); font-size: 14px;';
            
            // Botón siguiente
            const nextBtn = document.createElement('button');
            nextBtn.className = 'btn btn-outline';
            nextBtn.textContent = 'Siguiente →';
            nextBtn.disabled = currentPage === totalPages;
            nextBtn.onclick = () => {
                if (currentPage < totalPages) {
                    currentPage++;
                    displayResults();
                }
            };
            
            paginationDiv.appendChild(prevBtn);
            paginationDiv.appendChild(pageInfo);
            paginationDiv.appendChild(nextBtn);
            container.appendChild(paginationDiv);
        }
        
        // Formatear contenido con lazy loading
        function formatResultContent(result) {
            if (result.content && typeof result.content === 'string') {
                return `<p>${result.content}</p>`;
            }
            
            const dataToFormat = result.data || result;
            const resultId = result.id || Math.random().toString(36).substr(2, 9);
            
            // Check if this is evaluation data
            if (dataToFormat.modelos_evaluados) {
                return formatEvaluationData(dataToFormat, resultId);
            }
            
            return `
                <div class="interactive-controls">
                    <div class="test-counter">
                        <span class="counter-label">Elementos:</span>
                        <span class="counter-value" id="counter-${resultId}">${getObjectCount(dataToFormat)}</span>
                    </div>
                    <button class="json-btn" onclick="copyResultJSON('${resultId}')" title="Copiar JSON">
                        📋 Copiar
                    </button>
                    <button class="json-btn secondary" onclick="downloadResultJSON('${resultId}')" title="Descargar JSON">
                        💾 Descargar
                    </button>
                </div>
                <div class="interactive-list" id="list-${resultId}">
                    ${formatInteractiveList(dataToFormat, resultId)}
                </div>
            `;
        }
        
        // Cargar contenido detallado bajo demanda
        function loadDetailedContent(resultId) {
            const result = allResults.find(r => r.id === resultId) || filteredResults.find(r => r.id === resultId);
            if (!result) return;
            
            const container = document.querySelector(`#list-${resultId}`);
            if (!container) return;
            
            // Mostrar indicador de carga
            container.innerHTML = `
                <div class="loading-content">
                    <i data-lucide="loader-2" style="animation: spin 1s linear infinite;"></i>
                    <span>Cargando contenido...</span>
                </div>
            `;
            
            // Simular carga asíncrona para no bloquear la UI
            setTimeout(() => {
                const dataToFormat = result.data || result;
                container.innerHTML = formatInteractiveList(dataToFormat, resultId);
                lucide.createIcons();
            }, 100);
        }
        
        // Format evaluation data with simplified summary
        function formatEvaluationData(data, resultId) {
            const models = Object.keys(data.modelos_evaluados);
            
            // Calculate overall statistics
            let totalPrompts = 0;
            let successfulPrompts = 0;
            let totalErrors = 0;
            let avgScore = 0;
            let totalTime = 0;
            
            models.forEach(modelKey => {
                const model = data.modelos_evaluados[modelKey];
                if (model && model.categorias) {
                    Object.values(model.categorias).forEach(category => {
                        const prompts = category.prompts || [];
                        totalPrompts += prompts.length;
                        prompts.forEach(p => {
                            if (p.error) totalErrors++;
                            else successfulPrompts++;
                            avgScore += p.puntuacion || 0;
                            totalTime += p.tiempo_respuesta || 0;
                        });
                    });
                }
            });
            
            avgScore = totalPrompts > 0 ? (avgScore / totalPrompts).toFixed(1) : 0;
            const avgTime = totalPrompts > 0 ? (totalTime / totalPrompts).toFixed(2) : 0;
            const successRate = totalPrompts > 0 ? ((successfulPrompts / totalPrompts) * 100).toFixed(1) : 0;
            
            return `
                <div class="evaluation-summary">
                    <div class="summary-header">
                        <h4>📊 Resumen de Evaluación</h4>
                        <span class="models-count">${models.length} modelo(s) evaluado(s)</span>
                    </div>
                    
                    <div class="summary-stats">
                        <div class="stat-item">
                            <span class="stat-value">${totalPrompts}</span>
                            <span class="stat-label">Total Prompts</span>
                        </div>
                        <div class="stat-item success">
                            <span class="stat-value">${successfulPrompts}</span>
                            <span class="stat-label">Exitosos</span>
                        </div>
                        <div class="stat-item ${totalErrors > 0 ? 'error' : 'success'}">
                            <span class="stat-value">${totalErrors}</span>
                            <span class="stat-label">Errores</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value">${successRate}%</span>
                            <span class="stat-label">Tasa Éxito</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value">${avgScore}</span>
                            <span class="stat-label">Puntuación</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-value">${avgTime}s</span>
                            <span class="stat-label">Tiempo Medio</span>
                        </div>
                    </div>
                    
                    <div class="models-summary">
                        ${models.map(modelKey => {
                            const model = data.modelos_evaluados[modelKey];
                            const categories = Object.keys(model.categorias || {});
                            return `
                                <div class="model-summary">
                                    <strong>${modelKey.toUpperCase()}</strong>: ${categories.length} categorías evaluadas
                                </div>
                            `;
                        }).join('')}
                    </div>
                    
                    <div class="json-controls">
                        <button class="json-btn" onclick="copyResultJSON('${resultId}')" title="Copiar JSON completo">
                            📋 Copiar Datos
                        </button>
                        <button class="json-btn secondary" onclick="downloadResultJSON('${resultId}')" title="Descargar JSON">
                            💾 Descargar
                        </button>
                    </div>
                </div>
            `;
        }
        
        // Función formatJSONWithSyntaxHighlighting removida - ya no se necesita
        
        // Contar elementos en un objeto
        function getObjectCount(obj) {
            if (Array.isArray(obj)) {
                return obj.length;
            }
            if (typeof obj === 'object' && obj !== null) {
                return Object.keys(obj).length;
            }
            return 1;
        }
        
        // Formatear lista interactiva
        function formatInteractiveList(obj, resultId, path = '') {
            if (obj === null || obj === undefined) {
                return '<div class="list-item"><span class="item-key">null</span></div>';
            }
            
            if (typeof obj !== 'object') {
                return `<div class="list-item"><span class="item-value">${obj}</span></div>`;
            }
            
            let html = '';
            
            if (Array.isArray(obj)) {
                obj.forEach((item, index) => {
                    const itemPath = path ? `${path}[${index}]` : `[${index}]`;
                    html += `
                        <div class="list-item expandable" onclick="toggleListItem(this)">
                            <span class="item-toggle">▶</span>
                            <span class="item-key">[${index}]</span>
                            <span class="item-type">(${Array.isArray(item) ? 'array' : typeof item})</span>
                            <div class="item-children" style="display: none;">
                                ${formatInteractiveList(item, resultId, itemPath)}
                            </div>
                        </div>
                    `;
                });
            } else {
                Object.keys(obj).forEach(key => {
                    const value = obj[key];
                    const itemPath = path ? `${path}.${key}` : key;
                    
                    if (typeof value === 'object' && value !== null) {
                        html += `
                            <div class="list-item expandable" onclick="toggleListItem(this)">
                                <span class="item-toggle">▶</span>
                                <span class="item-key">${key}</span>
                                <span class="item-type">(${Array.isArray(value) ? 'array' : 'object'})</span>
                                <div class="item-children" style="display: none;">
                                    ${formatInteractiveList(value, resultId, itemPath)}
                                </div>
                            </div>
                        `;
                    } else {
                        html += `
                            <div class="list-item">
                                <span class="item-key">${key}:</span>
                                <span class="item-value">${value}</span>
                            </div>
                        `;
                    }
                });
            }
            
            return html;
        }
        
        // Toggle list item expansion
        function toggleListItem(element) {
            const children = element.querySelector('.item-children');
            const toggle = element.querySelector('.item-toggle');
            
            if (children.style.display === 'none') {
                children.style.display = 'block';
                toggle.textContent = '▼';
            } else {
                children.style.display = 'none';
                toggle.textContent = '▶';
            }
        }
        
        // Formatear timestamp
        function formatTimestamp(timestamp) {
            if (!timestamp) return 'Sin fecha';
            return new Date(timestamp).toLocaleString('es-ES');
        }
        
        // Debounce function para optimizar búsqueda
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        // Filtrar resultados con debouncing
        const filterResults = debounce(function() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            
            if (!searchTerm.trim()) {
                filteredResults = [...allResults];
            } else {
                filteredResults = allResults.filter(result => {
                    const searchableText = [
                        result.title || '',
                        result.content || '',
                        result.timestamp || ''
                    ].join(' ').toLowerCase();
                    
                    return searchableText.includes(searchTerm);
                });
            }
            
            // Resetear a la primera página cuando se filtra
            currentPage = 1;
            displayResults();
        }, 300);
        
        // Actualizar métricas
        function updateMetrics() {
            const total = allResults.length;
            let totalPrompts = 0;
            let successfulPrompts = 0;
            let totalResponseTime = 0;
            let responseCount = 0;
            let categoryScores = {};
            let categoryBreakdown = {};
            
            // Analizar datos de evaluación (optimizado)
            for (const result of allResults) {
                if (!result.data?.modelos_evaluados) continue;
                
                for (const modelo of Object.values(result.data.modelos_evaluados)) {
                    if (modelo.resumen) {
                        totalPrompts += modelo.resumen.prompts_evaluados || 0;
                        successfulPrompts += modelo.resumen.prompts_exitosos || 0;
                    }
                    
                    if (modelo.categorias) {
                        for (const [categoria, data] of Object.entries(modelo.categorias)) {
                            if (!categoryScores[categoria]) {
                                categoryScores[categoria] = [];
                                categoryBreakdown[categoria] = { total: 0, time: 0 };
                            }
                            
                            if (data.prompts) {
                                for (const prompt of data.prompts) {
                                    if (prompt.puntuacion !== undefined) {
                                        categoryScores[categoria].push(prompt.puntuacion);
                                    }
                                    if (prompt.tiempo_respuesta !== undefined) {
                                        totalResponseTime += prompt.tiempo_respuesta;
                                        responseCount++;
                                        categoryBreakdown[categoria].time += prompt.tiempo_respuesta;
                                        categoryBreakdown[categoria].total++;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            const successRate = totalPrompts > 0 ? Math.round((successfulPrompts / totalPrompts) * 100) : 0;
            const avgTime = responseCount > 0 ? (totalResponseTime / responseCount).toFixed(2) : 0;
            
            // Calcular puntuación promedio general
            const allScores = Object.values(categoryScores).flat();
            const avgScore = allScores.length > 0 ? (allScores.reduce((a, b) => a + b, 0) / allScores.length).toFixed(1) : 0;
            
            document.getElementById('totalTests').textContent = totalPrompts;
            document.getElementById('successRate').textContent = `${successRate}%`;
            document.getElementById('avgTime').textContent = `${avgTime}s`;
            document.getElementById('uptime').textContent = `${avgScore}/100`;
            
            // Actualizar métricas detalladas si existen
            updateDetailedMetrics(categoryScores, categoryBreakdown, totalResponseTime);
        }
        
        // Alternar métricas detalladas
         function toggleDetailedMetrics() {
             const detailedSection = document.getElementById('detailedMetrics');
             const toggleBtn = document.getElementById('toggleDetailedBtn');
             const icon = toggleBtn.querySelector('i');
             
             if (detailedSection.style.display === 'none' || !detailedSection.style.display) {
                 detailedSection.style.display = 'block';
                 toggleBtn.innerHTML = '<i data-lucide="chevron-up"></i> Ocultar Análisis Detallado';
             } else {
                 detailedSection.style.display = 'none';
                 toggleBtn.innerHTML = '<i data-lucide="chevron-down"></i> Ver Análisis Detallado';
             }
             lucide.createIcons();
         }
         
         // Actualizar métricas detalladas
         function updateDetailedMetrics(categoryScores, categoryBreakdown, totalResponseTime) {
             const detailedSection = document.getElementById('detailedMetrics');
             const toggleBtn = document.getElementById('toggleDetailedBtn');
             if (!detailedSection) return;
             
             // Mostrar botón y preparar sección si hay datos
             if (Object.keys(categoryScores).length > 0) {
                 toggleBtn.style.display = 'block';
                 detailedSection.style.display = 'none'; // Inicialmente oculto
                
                // Desglose por categorías
                const categoryEl = document.getElementById('categoryBreakdown');
                if (categoryEl) {
                    categoryEl.innerHTML = Object.entries(categoryScores).map(([categoria, scores]) => {
                        const avgScore = scores.length > 0 ? (scores.reduce((a, b) => a + b, 0) / scores.length).toFixed(1) : 0;
                        const percentage = Math.min(100, (avgScore / 100) * 100);
                        
                        return `
                            <div class="category-item">
                                <div>
                                    <div class="metric-name">${categoria}</div>
                                    <div class="progress-bar">
                                        <div class="progress-fill" style="width: ${percentage}%"></div>
                                    </div>
                                </div>
                                <div class="metric-value-detail">${avgScore}/100</div>
                            </div>
                        `;
                    }).join('');
                }
                
                // Distribución de tiempos
                const timeEl = document.getElementById('timeBreakdown');
                if (timeEl) {
                    timeEl.innerHTML = Object.entries(categoryBreakdown).map(([categoria, data]) => {
                        const avgTime = data.total > 0 ? (data.time / data.total).toFixed(2) : 0;
                        const maxTime = 10; // Tiempo máximo esperado en segundos
                        const percentage = Math.min(100, (avgTime / maxTime) * 100);
                        
                        return `
                            <div class="time-item">
                                <div>
                                    <div class="metric-name">${categoria}</div>
                                    <div class="progress-bar">
                                        <div class="progress-fill" style="width: ${percentage}%"></div>
                                    </div>
                                </div>
                                <div class="metric-value-detail">${avgTime}s</div>
                            </div>
                        `;
                    }).join('');
                }
                
                // Distribución de puntuaciones
                const scoreEl = document.getElementById('scoreDistribution');
                if (scoreEl) {
                    const allScores = Object.values(categoryScores).flat();
                    const ranges = {
                        'Excelente (90-100)': allScores.filter(s => s >= 90).length,
                        'Bueno (70-89)': allScores.filter(s => s >= 70 && s < 90).length,
                        'Regular (50-69)': allScores.filter(s => s >= 50 && s < 70).length,
                        'Bajo (<50)': allScores.filter(s => s < 50).length
                    };
                    
                    const total = allScores.length;
                    scoreEl.innerHTML = Object.entries(ranges).map(([range, count]) => {
                        const percentage = total > 0 ? ((count / total) * 100).toFixed(1) : 0;
                        const barWidth = total > 0 ? (count / total) * 100 : 0;
                        
                        return `
                            <div class="score-item">
                                <div>
                                    <div class="metric-name">${range}</div>
                                    <div class="progress-bar">
                                        <div class="progress-fill" style="width: ${barWidth}%"></div>
                                    </div>
                                </div>
                                <div class="metric-value-detail">${count} (${percentage}%)</div>
                            </div>
                        `;
                    }).join('');
                }
                
                // Resumen de rendimiento
                const performanceEl = document.getElementById('performanceSummary');
                if (performanceEl) {
                    const allScores = Object.values(categoryScores).flat();
                    const avgScore = allScores.length > 0 ? (allScores.reduce((a, b) => a + b, 0) / allScores.length).toFixed(1) : 0;
                    const totalCategories = Object.keys(categoryScores).length;
                    const totalPrompts = allScores.length;
                    
                    performanceEl.innerHTML = `
                        <div class="performance-item">
                            <div class="metric-name">Categorías Evaluadas</div>
                            <div class="metric-value-detail">${totalCategories}</div>
                        </div>
                        <div class="performance-item">
                            <div class="metric-name">Total Prompts</div>
                            <div class="metric-value-detail">${totalPrompts}</div>
                        </div>
                        <div class="performance-item">
                            <div class="metric-name">Puntuación Media</div>
                            <div class="metric-value-detail">${avgScore}/100</div>
                        </div>
                        <div class="performance-item">
                            <div class="metric-name">Estado General</div>
                            <div class="metric-value-detail">${avgScore >= 80 ? '🟢 Excelente' : avgScore >= 60 ? '🟡 Bueno' : '🔴 Necesita Mejora'}</div>
                        </div>
                    `;
                }
             } else {
                 toggleBtn.style.display = 'none';
                 detailedSection.style.display = 'none';
             }
         }
        
        // Variables para seguimiento de progreso
        let activeProgressTrackers = new Map();
        
        // Verificar configuración de API
        async function checkApiConfiguration() {
            try {
                const response = await fetch('/api/results/config-check');
                return await response.json();
            } catch (error) {
                console.error('Error checking API configuration:', error);
                return { can_run_tests: false, can_run_evaluations: false, message: 'Error de conexión' };
            }
        }
        
        // Seguimiento de progreso
        async function trackProgress(sessionId, progressEndpoint, type) {
            const progressKey = `${type}_${sessionId}`;
            
            // Crear elemento de progreso
            const progressDiv = document.createElement('div');
            progressDiv.id = `progress_${progressKey}`;
            progressDiv.className = 'progress-tracker';
            progressDiv.innerHTML = `
                <div class="progress-header">
                    <span class="progress-title">${type === 'test' ? 'Ejecutando Pruebas' : 'Ejecutando Evaluaciones'}</span>
                    <button class="progress-close" onclick="cancelProgress('${progressKey}')" title="Cancelar">
                        <i data-lucide="x"></i>
                    </button>
                </div>
                <div class="progress-bar-container">
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: 0%"></div>
                    </div>
                    <span class="progress-text">0%</span>
                </div>
                <div class="progress-message">Iniciando...</div>
            `;
            
            // Agregar al DOM
            const container = document.getElementById('resultsContainer');
            container.insertBefore(progressDiv, container.firstChild);
            
            // Inicializar iconos
            lucide.createIcons();
            
            // Función de seguimiento
            const trackInterval = setInterval(async () => {
                try {
                    const response = await fetch(progressEndpoint);
                    const progress = await response.json();
                    
                    // Actualizar UI
                    const progressBar = progressDiv.querySelector('.progress-fill');
                    const progressText = progressDiv.querySelector('.progress-text');
                    const progressMessage = progressDiv.querySelector('.progress-message');
                    
                    if (progressBar) progressBar.style.width = `${progress.progress}%`;
                    if (progressText) progressText.textContent = `${progress.progress}%`;
                    if (progressMessage) progressMessage.textContent = progress.message || 'Procesando...';
                    
                    // Verificar si terminó
                    if (progress.status === 'completed' || progress.status === 'error') {
                        clearInterval(trackInterval);
                        activeProgressTrackers.delete(progressKey);
                        
                        if (progress.status === 'completed') {
                            showNotification(`${type === 'test' ? 'Pruebas' : 'Evaluaciones'} completadas correctamente`);
                            // Esperar un momento antes de recargar para que se vea el 100%
                            setTimeout(() => {
                                progressDiv.remove();
                                loadResults();
                            }, 2000);
                        } else {
                            showNotification(`Error en ${type === 'test' ? 'pruebas' : 'evaluaciones'}: ${progress.error || 'Error desconocido'}`, 'error');
                            setTimeout(() => progressDiv.remove(), 5000);
                        }
                    }
                    
                } catch (error) {
                    console.error('Error tracking progress:', error);
                    clearInterval(trackInterval);
                    activeProgressTrackers.delete(progressKey);
                    showNotification('Error siguiendo el progreso', 'error');
                    setTimeout(() => progressDiv.remove(), 3000);
                }
            }, 1000); // Verificar cada segundo
            
            // Guardar referencia para poder cancelar
            activeProgressTrackers.set(progressKey, {
                interval: trackInterval,
                element: progressDiv
            });
        }
        
        // Cancelar seguimiento de progreso
        function cancelProgress(progressKey) {
            const tracker = activeProgressTrackers.get(progressKey);
            if (tracker) {
                clearInterval(tracker.interval);
                tracker.element.remove();
                activeProgressTrackers.delete(progressKey);
                showNotification('Seguimiento cancelado');
            }
        }
        
        // Ejecutar pruebas con seguimiento de progreso
        async function runTests() {
            try {
                // Verificar configuración primero
                const config = await checkApiConfiguration();
                if (!config.can_run_tests) {
                    showNotification(`No se pueden ejecutar pruebas: ${config.message}`, 'error');
                    return;
                }
                
                const response = await fetch('/api/results/run-tests', { method: 'POST' });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    if (errorData.detail && errorData.detail.error === 'missing_api_keys') {
                        showNotification(`Error: ${errorData.detail.message}`, 'error');
                        return;
                    }
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.session_id && result.progress_endpoint) {
                    // Iniciar seguimiento de progreso
                    trackProgress(result.session_id, result.progress_endpoint, 'test');
                } else {
                    // Fallback para compatibilidad
                    showNotification('Pruebas iniciadas');
                    setTimeout(loadResults, 2000);
                }
                
            } catch (error) {
                console.error('Error running tests:', error);
                showNotification(`Error al ejecutar pruebas: ${error.message}`, 'error');
            }
        }
        
        // Ejecutar evaluaciones con seguimiento de progreso
        async function runEvaluations() {
            try {
                // Verificar configuración primero
                const config = await checkApiConfiguration();
                if (!config.can_run_evaluations) {
                    showNotification(`No se pueden ejecutar evaluaciones: ${config.message}`, 'error');
                    return;
                }
                
                const response = await fetch('/api/results/run-evaluations', { method: 'POST' });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    if (errorData.detail && errorData.detail.error === 'missing_api_keys') {
                        showNotification(`Error: ${errorData.detail.message}`, 'error');
                        return;
                    }
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.session_id && result.progress_endpoint) {
                    // Iniciar seguimiento de progreso
                    trackProgress(result.session_id, result.progress_endpoint, 'evaluation');
                } else {
                    // Fallback para compatibilidad
                    showNotification('Evaluaciones iniciadas');
                    setTimeout(loadResults, 2000);
                }
                
            } catch (error) {
                console.error('Error running evaluations:', error);
                showNotification(`Error al ejecutar evaluaciones: ${error.message}`, 'error');
            }
        }
        

        
        // Exportar resultados
        function exportResults() {
            const dataStr = JSON.stringify(allResults, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `resultados_${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            
            URL.revokeObjectURL(url);
            showNotification('Resultados exportados correctamente');
        }
        
        // Mostrar notificación
        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${type === 'error' ? '#dc2626' : '#22c55e'};
                color: white;
                padding: 1rem 1.5rem;
                border-radius: 8px;
                z-index: 1000;
                animation: slideIn 0.3s ease;
            `;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }
        
        // Toggle tema
        function toggleTheme() {
            const isDark = document.documentElement.classList.toggle('dark');
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
        }
        
        // Funciones para controles JSON individuales
        
        // Copiar JSON de resultado individual
        function copyResultJSON(resultId) {
            const result = filteredResults.find(r => r.id === resultId);
            if (!result) {
                showNotification('No se pudo encontrar el resultado', 'error');
                return;
            }
            
            const dataToFormat = result.data || result;
            const jsonString = JSON.stringify(dataToFormat, null, 2);
            
            navigator.clipboard.writeText(jsonString).then(() => {
                showNotification('JSON copiado al portapapeles');
            }).catch(err => {
                console.error('Error al copiar:', err);
                showNotification('Error al copiar JSON', 'error');
            });
        }
        
        // Descargar JSON de resultado individual
        function downloadResultJSON(resultId) {
            const result = filteredResults.find(r => r.id === resultId);
            if (!result) {
                showNotification('No se pudo encontrar el resultado', 'error');
                return;
            }
            
            const dataToFormat = result.data || result;
            const jsonString = JSON.stringify(dataToFormat, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `resultado_${new Date().toISOString().slice(0, 10)}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            showNotification('JSON descargado correctamente');
        }
        
        // Función removida: toggleJSONFormat ya no es necesaria con la lista interactiva
        
        // Cargar resultados de pruebas HTML
        async function loadTestResults() {
            try {
                const response = await fetch('/api/results/test-results');
                if (response.ok) {
                    const testResults = await response.json();
                    displayTestResults(testResults);
                }
            } catch (error) {
                console.error('Error loading test results:', error);
            }
        }
        
        // Mostrar resultados de pruebas
        function displayTestResults(testResults) {
            if (!testResults || testResults.length === 0) return;
            
            // Parse test data from the first result (assuming it contains the test summary)
            const testData = testResults[0]?.data || {};
            const passedTests = testData.passed_tests || 0;
            const failedTests = testData.failed_tests || 0;
            const skippedTests = testData.skipped_tests || 0;
            const totalTests = testData.total_tests || 0;
            const testDetails = testData.test_details || [];
            
            // Create status summary
            const statusCounts = {
                passed: passedTests,
                failed: failedTests,
                skipped: skippedTests
            };
            
            // Generate keyword list
            const keywordList = testDetails.map(test => {
                const status = test.status === 'passed' ? '✅ passed' : 
                              test.status === 'failed' ? '❌ error' : 
                              test.status === 'skipped' ? '⏭️ skipped' : '⚠️ unknown';
                return `<li>${test.name.split('::').pop()} - ${status}</li>`;
            }).join('');
            
            const testSection = document.createElement('div');
            testSection.className = 'test-results-section';
            testSection.innerHTML = `
                <h2 class="results-title">Reportes de Pruebas</h2>
                <div class="result-card">
                    <div class="result-header">
                        <h3 class="result-title">Resumen de Pruebas</h3>
                        <span class="result-timestamp">${formatTimestamp(testData.timestamp)}</span>
                    </div>
                    <div class="result-content">
                        <div class="test-counter">
                            <div class="counter-item">
                                <span class="counter-value">${totalTests}</span>
                                <span class="counter-label">Total</span>
                            </div>
                            <div class="counter-item success">
                                <span class="counter-value">${passedTests}</span>
                                <span class="counter-label">Passed</span>
                            </div>
                            <div class="counter-item error">
                                <span class="counter-value">${failedTests}</span>
                                <span class="counter-label">Failed</span>
                            </div>
                            <div class="counter-item warning">
                                <span class="counter-value">${skippedTests}</span>
                                <span class="counter-label">Skipped</span>
                            </div>
                        </div>
                        <div class="test-list">
                            <h4>Detalles de Pruebas:</h4>
                            <ul class="keyword-list">
                                ${keywordList}
                            </ul>
                        </div>
                    </div>
                </div>
            `;
            
            const resultsSection = document.querySelector('.results-section');
            resultsSection.parentNode.insertBefore(testSection, resultsSection);
        }
        

        
        // Enhanced copy function for evaluation data
        function copyEvaluationData(resultId, format = 'json') {
            const result = allResults.find(r => r.id === resultId);
            if (!result) return;
            
            let textToCopy = '';
            
            if (format === 'summary') {
                // Create a summary text
                const data = result.data;
                const models = Object.keys(data.modelos_evaluados);
                
                textToCopy = `Resumen de Evaluación\n`;
                textToCopy += `Timestamp: ${data.timestamp}\n\n`;
                
                models.forEach(modelKey => {
                    const model = data.modelos_evaluados[modelKey];
                    const categories = Object.keys(model.categorias || {});
                    
                    let totalPrompts = 0;
                    let successfulPrompts = 0;
                    let totalErrors = 0;
                    
                    categories.forEach(cat => {
                        const prompts = model.categorias[cat].prompts || [];
                        totalPrompts += prompts.length;
                        prompts.forEach(p => {
                            if (p.error) totalErrors++;
                            else successfulPrompts++;
                        });
                    });
                    
                    textToCopy += `Modelo: ${modelKey.toUpperCase()}\n`;
                    textToCopy += `- Total prompts: ${totalPrompts}\n`;
                    textToCopy += `- Exitosos: ${successfulPrompts}\n`;
                    textToCopy += `- Con errores: ${totalErrors}\n`;
                    textToCopy += `- Tasa de éxito: ${totalPrompts > 0 ? ((successfulPrompts / totalPrompts) * 100).toFixed(1) : 0}%\n\n`;
                });
            } else {
                textToCopy = JSON.stringify(result.data, null, 2);
            }
            
            navigator.clipboard.writeText(textToCopy).then(() => {
                showNotification(`${format === 'summary' ? 'Resumen' : 'JSON'} copiado al portapapeles`);
            }).catch(() => {
                showNotification('Error al copiar al portapapeles', 'error');
            });
        }
        
        // Enhanced export function
        function exportEvaluationData(resultId, format = 'json') {
            const result = allResults.find(r => r.id === resultId);
            if (!result) return;
            
            let content = '';
            let filename = '';
            let mimeType = '';
            
            if (format === 'csv') {
                // Convert to CSV format
                const data = result.data;
                const models = Object.keys(data.modelos_evaluados);
                
                content = 'Modelo,Categoría,Prompt,Puntuación,Tiempo_Respuesta,Error\n';
                
                models.forEach(modelKey => {
                    const model = data.modelos_evaluados[modelKey];
                    Object.entries(model.categorias || {}).forEach(([categoryName, categoryData]) => {
                        const prompts = categoryData.prompts || [];
                        prompts.forEach(prompt => {
                            const row = [
                                modelKey,
                                categoryName,
                                `"${prompt.prompt.replace(/"/g, '""')}"`,
                                prompt.puntuacion || 0,
                                prompt.tiempo_respuesta || 0,
                                prompt.error ? `"${prompt.error.replace(/"/g, '""')}"` : ''
                            ].join(',');
                            content += row + '\n';
                        });
                    });
                });
                
                filename = `evaluacion_${data.evaluacion_id || 'export'}.csv`;
                mimeType = 'text/csv';
            } else {
                content = JSON.stringify(result.data, null, 2);
                filename = `evaluacion_${result.data.evaluacion_id || 'export'}.json`;
                mimeType = 'application/json';
            }
            
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            
            URL.revokeObjectURL(url);
            showNotification(`Datos exportados como ${format.toUpperCase()}`);
        }
        
        // Inicializar
        document.addEventListener('DOMContentLoaded', function() {
            // Theme toggle
            document.getElementById('themeToggle').addEventListener('click', toggleTheme);
            
            // Cargar resultados iniciales
            loadResults();
            loadTestResults();
            
            // Inicializar iconos
            lucide.createIcons();
        });
    </script>
</body>
</html>